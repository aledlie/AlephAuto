This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
README_ENHANCED.md
readme-scanner.js
schema-enhancement-worker.js
schema-mcp-tools.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="README_ENHANCED.md">
# doc-enhancement

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "SoftwareSourceCode",
  "name": "doc-enhancement",
  "description": "Directory containing 2 code files with 2 classes and 0 functions",
  "programmingLanguage": [
    {
      "@type": "ComputerLanguage",
      "name": "Typescript"
    }
  ],
  "featureList": [
    "2 class definitions"
  ]
}
</script>

## Overview

This directory contains 2 code file(s) with extracted schemas.

## Files and Schemas

### `readme-scanner.js` (typescript)

**Classes:**
- `READMEScanner` - Line 6

### `schema-mcp-tools.js` (typescript)

**Classes:**
- `SchemaMCPTools` - Line 5

---
*Generated by Enhanced Schema Generator with schema.org markup*
</file>

<file path="readme-scanner.js">
import fs from 'fs/promises';
import path from 'path';

/**
 * READMEScanner - Recursively scans for README.md files
 */
export class READMEScanner {
  constructor(options = {}) {
    this.baseDir = options.baseDir || process.cwd();
    this.excludeDirs = new Set(options.excludeDirs || [
      'node_modules',
      '.git',
      'dist',
      'build',
      'coverage',
      '.next',
      '.nuxt',
      'vendor',
      '__pycache__',
      '.venv',
      'venv',
      '_site',
      '.cache',
      'target',
      '.idea',
      '.vscode',
    ]);
    this.maxDepth = options.maxDepth || 10;
    this.readmePatterns = options.readmePatterns || [
      'README.md',
      'readme.md',
      'Readme.md',
      'README_ENHANCED.md',
    ];
  }

  /**
   * Scan all README files recursively
   */
  async scanREADMEs() {
    const readmes = [];
    await this.scanRecursive(this.baseDir, '', 0, readmes);
    return readmes;
  }

  /**
   * Recursively scan a directory for README files
   */
  async scanRecursive(currentPath, relativePath, depth, results) {
    // Check depth limit
    if (depth > this.maxDepth) {
      return;
    }

    try {
      const entries = await fs.readdir(currentPath, { withFileTypes: true });

      for (const entry of entries) {
        if (entry.isDirectory()) {
          // Skip excluded directories
          if (this.excludeDirs.has(entry.name) || entry.name.startsWith('.')) {
            continue;
          }

          const fullPath = path.join(currentPath, entry.name);
          const newRelativePath = relativePath
            ? path.join(relativePath, entry.name)
            : entry.name;

          // Recurse into subdirectories
          await this.scanRecursive(fullPath, newRelativePath, depth + 1, results);
        } else if (entry.isFile() && this.isREADMEFile(entry.name)) {
          const fullPath = path.join(currentPath, entry.name);
          const fileRelativePath = relativePath
            ? path.join(relativePath, entry.name)
            : entry.name;

          results.push({
            fullPath,
            relativePath: fileRelativePath,
            fileName: entry.name,
            dirPath: currentPath,
            depth,
          });
        }
      }
    } catch (error) {
      // Log but don't fail on permission errors
      console.warn(`Warning: Cannot access ${currentPath}:`, error.message);
    }
  }

  /**
   * Check if filename matches README patterns
   */
  isREADMEFile(filename) {
    return this.readmePatterns.includes(filename);
  }

  /**
   * Check if README already has schema markup
   */
  async hasSchemaMarkup(readmePath) {
    try {
      const content = await fs.readFile(readmePath, 'utf-8');
      return content.includes('<script type="application/ld+json">');
    } catch (error) {
      return false;
    }
  }

  /**
   * Read README content
   */
  async readREADME(readmePath) {
    try {
      return await fs.readFile(readmePath, 'utf-8');
    } catch (error) {
      throw new Error(`Failed to read README at ${readmePath}: ${error.message}`);
    }
  }

  /**
   * Gather context about a directory
   */
  async gatherContext(dirPath) {
    const context = {
      languages: new Set(),
      gitRemote: null,
      hasPackageJson: false,
      hasPyproject: false,
      projectType: 'unknown',
    };

    try {
      const entries = await fs.readdir(dirPath);

      for (const entry of entries) {
        const fullPath = path.join(dirPath, entry);
        const stat = await fs.stat(fullPath);

        if (stat.isFile()) {
          // Detect languages by file extensions
          const ext = path.extname(entry);

          if (ext === '.py') context.languages.add('Python');
          if (['.ts', '.tsx'].includes(ext)) context.languages.add('TypeScript');
          if (['.js', '.jsx'].includes(ext)) context.languages.add('JavaScript');
          if (['.java'].includes(ext)) context.languages.add('Java');
          if (['.go'].includes(ext)) context.languages.add('Go');
          if (['.rs'].includes(ext)) context.languages.add('Rust');
          if (['.rb'].includes(ext)) context.languages.add('Ruby');

          // Check for project markers
          if (entry === 'package.json') {
            context.hasPackageJson = true;
            context.projectType = 'nodejs';
          }
          if (entry === 'pyproject.toml' || entry === 'setup.py') {
            context.hasPyproject = true;
            context.projectType = 'python';
          }
        }
      }

      // Try to get git remote
      context.gitRemote = await this.getGitRemote(dirPath);
    } catch (error) {
      console.warn(`Warning gathering context for ${dirPath}:`, error.message);
    }

    return context;
  }

  /**
   * Get git remote URL for a directory
   */
  async getGitRemote(dirPath) {
    try {
      const { exec } = await import('child_process');
      const { promisify } = await import('util');
      const execAsync = promisify(exec);

      const { stdout } = await execAsync('git remote get-url origin', {
        cwd: dirPath,
        timeout: 5000,
      });

      return stdout.trim();
    } catch (error) {
      return null;
    }
  }

  /**
   * Get statistics about scanned READMEs
   */
  async getStats(readmes) {
    const stats = {
      total: readmes.length,
      withSchema: 0,
      withoutSchema: 0,
      byDepth: {},
    };

    for (const readme of readmes) {
      const hasSchema = await this.hasSchemaMarkup(readme.fullPath);
      if (hasSchema) {
        stats.withSchema++;
      } else {
        stats.withoutSchema++;
      }

      const depth = readme.depth;
      stats.byDepth[depth] = (stats.byDepth[depth] || 0) + 1;
    }

    return stats;
  }
}
</file>

<file path="schema-enhancement-worker.js">
import { SidequestServer } from '../server.js';
import { SchemaMCPTools } from './schema-mcp-tools.js';
import { READMEScanner } from './readme-scanner.js';
import fs from 'fs/promises';
import path from 'path';

/**
 * SchemaEnhancementWorker - Enhances README files with Schema.org markup
 */
export class SchemaEnhancementWorker extends SidequestServer {
  constructor(options = {}) {
    super(options);
    this.outputBaseDir = options.outputBaseDir || './document-enhancement-impact-measurement';
    this.mcpTools = new SchemaMCPTools(options);
    this.scanner = new READMEScanner(options);
    this.dryRun = options.dryRun || false;
    this.stats = {
      enhanced: 0,
      skipped: 0,
      failed: 0,
    };
  }

  /**
   * Run enhancement for a specific README file
   */
  async runJobHandler(job) {
    const { readmePath, relativePath, context } = job.data;

    console.log(`[${job.id}] Enhancing: ${readmePath}`);

    try {
      // Read README content
      const originalContent = await fs.readFile(readmePath, 'utf-8');

      // Check if already has schema
      if (originalContent.includes('<script type="application/ld+json">')) {
        console.log(`[${job.id}] Skipped - already has schema markup`);
        this.stats.skipped++;
        return {
          status: 'skipped',
          reason: 'Already has schema markup',
          readmePath,
          relativePath,
        };
      }

      // Get appropriate schema type
      const schemaType = await this.mcpTools.getSchemaType(
        readmePath,
        originalContent,
        context
      );

      console.log(`[${job.id}] Schema type: ${schemaType}`);

      // Generate schema markup
      const schema = await this.mcpTools.generateSchema(
        readmePath,
        originalContent,
        context,
        schemaType
      );

      // Validate schema
      const validation = await this.mcpTools.validateSchema(schema);
      if (!validation.valid) {
        throw new Error(`Schema validation failed: ${validation.errors.join(', ')}`);
      }

      if (validation.warnings.length > 0) {
        console.warn(`[${job.id}] Warnings: ${validation.warnings.join(', ')}`);
      }

      // Inject schema into content
      const enhancedContent = this.mcpTools.injectSchema(originalContent, schema);

      // Analyze impact
      const impact = await this.mcpTools.analyzeSchemaImpact(
        originalContent,
        enhancedContent,
        schema
      );

      console.log(`[${job.id}] Impact score: ${impact.impactScore}/100 (${impact.rating})`);

      // Save enhanced README
      if (!this.dryRun) {
        await fs.writeFile(readmePath, enhancedContent, 'utf-8');
        console.log(`[${job.id}] Enhanced README saved`);
      } else {
        console.log(`[${job.id}] Dry run - no changes made`);
      }

      // Save impact report
      await this.saveImpactReport(relativePath, schema, impact);

      // Save enhanced copy to output directory
      await this.saveEnhancedCopy(relativePath, enhancedContent);

      this.stats.enhanced++;

      return {
        status: 'enhanced',
        readmePath,
        relativePath,
        schemaType,
        schema,
        impact,
        validation,
        timestamp: new Date().toISOString(),
      };

    } catch (error) {
      this.stats.failed++;
      throw error;
    }
  }

  /**
   * Save impact report to output directory
   */
  async saveImpactReport(relativePath, schema, impact) {
    const reportDir = path.join(
      this.outputBaseDir,
      'impact-reports',
      path.dirname(relativePath)
    );

    await fs.mkdir(reportDir, { recursive: true });

    const reportPath = path.join(
      reportDir,
      `${path.basename(relativePath, '.md')}-impact.json`
    );

    const report = {
      relativePath,
      schema,
      impact,
      timestamp: new Date().toISOString(),
    };

    await fs.writeFile(reportPath, JSON.stringify(report, null, 2));
  }

  /**
   * Save enhanced copy to output directory
   */
  async saveEnhancedCopy(relativePath, enhancedContent) {
    const outputDir = path.join(
      this.outputBaseDir,
      'enhanced-readmes',
      path.dirname(relativePath)
    );

    await fs.mkdir(outputDir, { recursive: true });

    const outputPath = path.join(outputDir, path.basename(relativePath));

    await fs.writeFile(outputPath, enhancedContent, 'utf-8');
  }

  /**
   * Create an enhancement job for a README
   */
  createEnhancementJob(readme, context) {
    const jobId = `schema-${readme.relativePath.replace(/\//g, '-')}-${Date.now()}`;

    return this.createJob(jobId, {
      readmePath: readme.fullPath,
      relativePath: readme.relativePath,
      context,
      type: 'schema-enhancement',
    });
  }

  /**
   * Get enhancement statistics
   */
  getEnhancementStats() {
    return {
      ...this.stats,
      total: this.stats.enhanced + this.stats.skipped + this.stats.failed,
      successRate: this.stats.enhanced > 0
        ? ((this.stats.enhanced / (this.stats.enhanced + this.stats.failed)) * 100).toFixed(2)
        : 0,
    };
  }

  /**
   * Generate enhancement summary report
   */
  async generateSummaryReport() {
    const stats = this.getEnhancementStats();
    const jobStats = this.getStats();

    const summary = {
      timestamp: new Date().toISOString(),
      enhancement: stats,
      jobs: jobStats,
      outputDirectory: this.outputBaseDir,
    };

    const summaryPath = path.join(
      this.outputBaseDir,
      `enhancement-summary-${Date.now()}.json`
    );

    await fs.mkdir(this.outputBaseDir, { recursive: true });
    await fs.writeFile(summaryPath, JSON.stringify(summary, null, 2));

    return summary;
  }
}
</file>

<file path="schema-mcp-tools.js">
/**
 * Schema.org MCP Tools Integration
 * Provides wrapper methods for Schema.org MCP server tools
 */

export class SchemaMCPTools {
  constructor(options = {}) {
    this.mcpServerUrl = options.mcpServerUrl || process.env.SCHEMA_MCP_URL;
    this.useRealMCP = options.useRealMCP || false;
  }

  /**
   * Get appropriate schema type for content
   * Maps to MCP tool: get_schema_type
   */
  async getSchemaType(readmePath, content, context) {
    // In real implementation, this would call the MCP server
    // For now, we'll use heuristics like the Python version

    const pathLower = readmePath.toLowerCase();
    const contentLower = content.toLowerCase();

    // Test documentation
    if (pathLower.includes('test') || contentLower.includes('testing guide')) {
      return 'HowTo';
    }

    // API documentation
    if (pathLower.includes('api') ||
        contentLower.includes('api reference') ||
        contentLower.includes('endpoints')) {
      return 'APIReference';
    }

    // Software application
    if (context.hasPackageJson || context.hasPyproject) {
      return 'SoftwareApplication';
    }

    // Tutorial/Guide
    if (contentLower.includes('tutorial') ||
        contentLower.includes('getting started') ||
        contentLower.includes('guide')) {
      return 'HowTo';
    }

    // Code repository/technical documentation
    if (context.gitRemote) {
      return 'SoftwareSourceCode';
    }

    // Default to TechArticle
    return 'TechArticle';
  }

  /**
   * Generate JSON-LD schema markup
   * Maps to MCP tool: generate_example
   */
  async generateSchema(readmePath, content, context, schemaType) {
    const schema = {
      '@context': 'https://schema.org',
      '@type': schemaType,
    };

    // Extract title from first heading
    const titleMatch = content.match(/^#\s+(.+)$/m);
    if (titleMatch) {
      schema.name = titleMatch[1].trim();
    } else {
      // Fallback to directory name
      const dirName = readmePath.split('/').slice(-2, -1)[0];
      schema.name = dirName || 'Documentation';
    }

    // Extract description from content
    const description = this.extractDescription(content);
    if (description) {
      schema.description = description;
    }

    // Add common properties based on schema type
    if (schemaType === 'SoftwareApplication' || schemaType === 'SoftwareSourceCode') {
      if (context.gitRemote) {
        schema.codeRepository = context.gitRemote;
      }

      if (context.languages && context.languages.length > 0) {
        schema.programmingLanguage = context.languages.map(lang => ({
          '@type': 'ComputerLanguage',
          name: lang,
        }));
      }

      if (schemaType === 'SoftwareApplication') {
        schema.applicationCategory = 'DeveloperApplication';
        schema.operatingSystem = 'Cross-platform';
      }
    }

    if (schemaType === 'TechArticle' || schemaType === 'HowTo') {
      schema.dateModified = new Date().toISOString();
      schema.inLanguage = 'en-US';
    }

    if (schemaType === 'APIReference') {
      schema.additionalType = 'https://schema.org/TechArticle';
      if (context.gitRemote) {
        schema.url = context.gitRemote;
      }
    }

    return schema;
  }

  /**
   * Extract description from README content
   */
  extractDescription(content) {
    // Try to get the first paragraph after the title
    const lines = content.split('\n');
    let foundTitle = false;
    let description = '';

    for (const line of lines) {
      const trimmed = line.trim();

      // Skip title
      if (trimmed.startsWith('#')) {
        foundTitle = true;
        continue;
      }

      // Skip empty lines and code blocks
      if (!trimmed || trimmed.startsWith('```') || trimmed.startsWith('<')) {
        if (description) break; // Stop at first empty line after description
        continue;
      }

      // Found description
      if (foundTitle && trimmed.length > 10) {
        description = trimmed;
        break;
      }
    }

    // Limit description length
    if (description.length > 200) {
      description = description.substring(0, 197) + '...';
    }

    return description || 'Technical documentation and guides';
  }

  /**
   * Validate schema markup
   * Maps to Schema.org validation tools
   */
  async validateSchema(schema) {
    // Basic validation
    const errors = [];
    const warnings = [];

    // Check required fields
    if (!schema['@context']) {
      errors.push('Missing @context');
    }
    if (!schema['@type']) {
      errors.push('Missing @type');
    }
    if (!schema.name) {
      warnings.push('Missing name property');
    }
    if (!schema.description) {
      warnings.push('Missing description property');
    }

    // Validate JSON-LD format
    try {
      JSON.stringify(schema);
    } catch (e) {
      errors.push(`Invalid JSON: ${e.message}`);
    }

    return {
      valid: errors.length === 0,
      errors,
      warnings,
    };
  }

  /**
   * Analyze schema impact on SEO/performance
   * Maps to MCP tool: analyze_schema_impact
   */
  async analyzeSchemaImpact(originalContent, enhancedContent, schema) {
    const impact = {
      timestamp: new Date().toISOString(),
      schemaType: schema['@type'],
      metrics: {
        contentSize: {
          original: originalContent.length,
          enhanced: enhancedContent.length,
          increase: enhancedContent.length - originalContent.length,
        },
        schemaProperties: Object.keys(schema).length,
        structuredDataAdded: true,
      },
      seoImprovements: [],
      richResultsEligibility: [],
    };

    // Analyze SEO improvements
    if (schema.name) {
      impact.seoImprovements.push('Added structured name/title');
    }
    if (schema.description) {
      impact.seoImprovements.push('Added structured description');
    }
    if (schema.codeRepository) {
      impact.seoImprovements.push('Linked to code repository');
    }
    if (schema.programmingLanguage) {
      impact.seoImprovements.push('Specified programming languages');
    }

    // Check Rich Results eligibility
    const schemaType = schema['@type'];
    if (schemaType === 'HowTo') {
      impact.richResultsEligibility.push('How-to rich results');
    }
    if (schemaType === 'SoftwareApplication') {
      impact.richResultsEligibility.push('Software app rich results');
    }
    if (schemaType === 'TechArticle') {
      impact.richResultsEligibility.push('Article rich results');
    }

    // Calculate impact score (0-100)
    let score = 0;
    score += impact.seoImprovements.length * 15;
    score += impact.richResultsEligibility.length * 20;
    score += schema.description ? 20 : 0;
    score += schema.codeRepository ? 15 : 0;

    impact.impactScore = Math.min(100, score);
    impact.rating = this.getRating(impact.impactScore);

    return impact;
  }

  /**
   * Get rating based on impact score
   */
  getRating(score) {
    if (score >= 80) return 'Excellent';
    if (score >= 60) return 'Good';
    if (score >= 40) return 'Fair';
    return 'Needs Improvement';
  }

  /**
   * Create JSON-LD script tag
   */
  createJSONLDScript(schema) {
    const jsonStr = JSON.stringify(schema, null, 2);
    return `<script type="application/ld+json">\n${jsonStr}\n</script>`;
  }

  /**
   * Inject schema into README content
   */
  injectSchema(content, schema) {
    const jsonldScript = this.createJSONLDScript(schema);
    const lines = content.split('\n');

    // Find first heading
    let insertIndex = 0;
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].trim().startsWith('#')) {
        insertIndex = i + 1;
        break;
      }
    }

    // Insert schema after first heading with blank lines
    lines.splice(insertIndex, 0, '', jsonldScript, '');

    return lines.join('\n');
  }
}
</file>

</files>
